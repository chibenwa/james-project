2024-01-29 11:01:47
{"timestamp":"2024-01-29T10:01:47.691Z","level":"ERROR","thread":"s1-io-3","mdc":{"proxy.destination":"/185.60.150.47:993","proxy.ip":"10.233.66.36","idSet":"11->4929","fetchedData":"FetchData{items=[FLAGS, UID, INTERNAL_DATE, SIZE], setSeen=false, bodyElements=[BodyFetchElement{name=BODY[], sectionType=CONTENT}], changedSince=-1, vanished=false}","protocol":"IMAP","proxy.source":"/109.209.49.50:32967","useUid":"true","selectedMailbox":"bce6f7c0-ba99-11ee-a3db-039945f2e399","ip":"109.209.49.50","action":"FETCH","user":"philippe.baron@avocat.fr"},"logger":"org.apache.james.imap.processor.AbstractMailboxProcessor","message":"Unexpected error during IMAP processing","context":"default","exception":"java.lang.OutOfMemoryError: Java heap space\n\tat org.apache.james.blob.objectstorage.aws.MinimalCopyBytesResponseTransformer$BaosSubscriber.<init>(MinimalCopyBytesResponseTransformer.java:90)\n\tat org.apache.james.blob.objectstorage.aws.MinimalCopyBytesResponseTransformer.onStream(MinimalCopyBytesResponseTransformer.java:74)\n\tat software.amazon.awssdk.core.async.listener.AsyncResponseTransformerListener$NotifyingAsyncResponseTransformer.onStream(AsyncResponseTransformerListener.java:93)\n\tat software.amazon.awssdk.core.internal.http.async.AsyncStreamingResponseHandler.onStream(AsyncStreamingResponseHandler.java:63)\n\tat software.amazon.awssdk.core.internal.http.IdempotentAsyncResponseHandler.onStream(IdempotentAsyncResponseHandler.java:108)\n\tat software.amazon.awssdk.core.internal.http.async.CombinedResponseAsyncHttpResponseHandler.onStream(CombinedResponseAsyncHttpResponseHandler.java:86)\n\tat software.amazon.awssdk.core.internal.http.async.AsyncAfterTransmissionInterceptorCallingResponseHandler.onStream(AsyncAfterTransmissionInterceptorCallingResponseHandler.java:86)\n\tat software.amazon.awssdk.http.nio.netty.internal.ResponseHandler.channelRead0(ResponseHandler.java:107)\n\tat software.amazon.awssdk.http.nio.netty.internal.ResponseHandler.channelRead0(ResponseHandler.java:75)\n\tat io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:99)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\n\tat software.amazon.awssdk.http.nio.netty.internal.nrs.HandlerPublisher.channelRead(HandlerPublisher.java:396)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\n\tat software.amazon.awssdk.http.nio.netty.internal.nrs.HttpStreamsHandler.channelRead(HttpStreamsHandler.java:200)\n\tat software.amazon.awssdk.http.nio.netty.internal.nrs.HttpStreamsClientHandler.channelRead(HttpStreamsClientHandler.java:173)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\n\tat io.netty.handler.logging.LoggingHandler.channelRead(LoggingHandler.java:280)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\n\tat io.netty.handler.timeout.IdleStateHandler.channelRead(IdleStateHandler.java:286)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\n\tat io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)\n\tat io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)\n"}

2024-01-29 11:01:47
{"timestamp":"2024-01-29T10:01:47.528Z","level":"ERROR","thread":"aws-java-sdk-NettyEventLoop-0-2","logger":"io.netty.util.ResourceLeakDetector","message":"LEAK: ByteBuf.release() was not called before it's garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information.\nRecent access records: \nCreated at:\n\tio.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:96)\n\tio.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:188)\n\tio.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:179)\n\tio.netty.buffer.AbstractByteBufAllocator.buffer(AbstractByteBufAllocator.java:116)\n\tio.netty.handler.ssl.SslHandler.allocate(SslHandler.java:2359)\n\tio.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1440)\n\tio.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1338)\n\tio.netty.handler.ssl.SslHandler.decode(SslHandler.java:1387)\n\tio.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:529)\n\tio.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:468)\n\tio.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\n\tio.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)\n\tio.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)\n\tio.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)\n\tio.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\n\tio.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)\n\tio.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)\n\tio.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)\n\tio.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)\n\tio.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)\n\tio.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)\n\tio.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tjava.base/java.lang.Thread.run(Unknown Source)","context":"default"}
2024-01-29 11:01:47
{"timestamp":"2024-01-29T10:01:47.527Z","level":"ERROR","thread":"parallel-2","logger":"reactor.core.scheduler.Schedulers","message":"Scheduler worker in group main failed with an uncaught exception","context":"default","exception":"java.lang.OutOfMemoryError: Java heap space\n\tat org.apache.commons.io.IOUtils.byteArray(IOUtils.java:365)\n\tat org.apache.commons.io.output.AbstractByteArrayOutputStream.needNewBuffer(AbstractByteArrayOutputStream.java:140)\n\tat org.apache.commons.io.output.AbstractByteArrayOutputStream.writeImpl(AbstractByteArrayOutputStream.java:331)\n\tat org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.write(UnsynchronizedByteArrayOutputStream.java:197)\n\tat org.apache.commons.io.output.ThresholdingOutputStream.write(ThresholdingOutputStream.java:232)\n\tat org.apache.commons.io.IOUtils.copyLarge(IOUtils.java:1486)\n\tat org.apache.commons.io.IOUtils.copy(IOUtils.java:1105)\n\tat org.apache.commons.io.IOUtils.copyLarge(IOUtils.java:1458)\n\tat org.apache.commons.io.IOUtils.copy(IOUtils.java:1083)\n\tat org.apache.commons.io.IOUtils.toByteArray(IOUtils.java:2648)\n\tat org.apache.james.blob.aes.AESBlobStoreDAO$$Lambda/0x00007f60c90a9868.doApply(Unknown Source)\n\tat com.github.fge.lambdas.functions.FunctionChainer.doApply(FunctionChainer.java:20)\n\tat com.github.fge.lambdas.functions.ThrowingFunction.apply(ThrowingFunction.java:17)\n\tat reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)\n\tat reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)\n\tat reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)\n\tat reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79)\n\tat reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)\n\tat reactor.core.publisher.MonoPublishOn$PublishOnSubscriber.run(MonoPublishOn.java:181)\n\tat reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:68)\n\tat reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:28)\n\tat java.base/java.util.concurrent.FutureTask.run(Unknown Source)\n\tat java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)\n\tat java.base/java.lang.Thread.runWith(Unknown Source)\n\tat java.base/java.lang.Thread.run(Unknown Source)\n"}

exception	java.lang.OutOfMemoryError: Java heap space
at org.apache.commons.io.IOUtils.byteArray(IOUtils.java:365)
at org.apache.commons.io.output.AbstractByteArrayOutputStream.needNewBuffer(AbstractByteArrayOutputStream.java:140)
at org.apache.commons.io.output.AbstractByteArrayOutputStream.writeImpl(AbstractByteArrayOutputStream.java:331)
at org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream.write(UnsynchronizedByteArrayOutputStream.java:197)
at org.apache.commons.io.output.ThresholdingOutputStream.write(ThresholdingOutputStream.java:232)
at org.apache.commons.io.IOUtils.copyLarge(IOUtils.java:1486)
at org.apache.commons.io.IOUtils.copy(IOUtils.java:1105)
at org.apache.commons.io.IOUtils.copyLarge(IOUtils.java:1458)
at org.apache.commons.io.IOUtils.copy(IOUtils.java:1083)
at org.apache.commons.io.IOUtils.toByteArray(IOUtils.java:2648)
at org.apache.james.blob.aes.AESBlobStoreDAO$$Lambda/0x00007f60c90a9868.doApply(Unknown Source)
at com.github.fge.lambdas.functions.FunctionChainer.doApply(FunctionChainer.java:20)
at com.github.fge.lambdas.functions.ThrowingFunction.apply(ThrowingFunction.java:17)
at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onNext(FluxOnErrorResume.java:79)
at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
at reactor.core.publisher.MonoPublishOn$PublishOnSubscriber.run(MonoPublishOn.java:181)
at reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:68)
at reactor.core.scheduler.SchedulerTask.call(SchedulerTask.java:28)
at java.base/java.util.concurrent.FutureTask.run(Unknown Source)
at java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(Unknown Source)
at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
at java.base/java.lang.Thread.runWith(Unknown Source)
at java.base/java.lang.Thread.run(Unknown Source)